/* All My LeetCode Questions */

/**
 * Merge Strings Alternatively
 * You are given two strings word1 and word2. 
 * Merge the strings by adding letters in alternating order, starting with word1. 
 * If a string is longer than the other, append the additional letters onto the end of the merged string.
 * 
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function(word1, word2) {
    let n = 0;
    let word = "";
    if (word1.length >= word2.length) {
        n = word1.length;
    } else {
        n = word2.length;
    }


    for(let i = 0; i<n; i++) {
        if(word1.charAt(i) && word2.charAt(i)) {
            word += word1.charAt(i) + word2.charAt(i);
        } else if (word1.charAt(i)){
            word += word1.charAt(i)
        } else {
            word += word2.charAt(i);
        }
    }

    return word;
};


/**
 * Find the Difference
 * You are given two strings s and t.
 * String t is generated by random shuffling string s and then add one more letter at a random position.
 * Return the letter that was added to t.
 * 
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    let letter;
    s = s.split('').sort().join('');
    t = t.split('').sort().join('');

    for(let i=0; i<s.length; i++){
        if (s.charAt(i) !== t.charAt(i)){
            return t.charAt(i);
        }
    }

    return t.charAt(t.length - 1);
};

/**
 * Find the Index of the First Occurrence in a String
 * Given two strings needle and haystack, 
 * return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
 * 
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    let position = haystack.search(needle);
    if (position == undefined) {
        position = -1;
    }
    return position;
};

/**
 * Valid Anagram
 * Given two strings s and t, return true if t is an anagram of s, and false otherwise.
 * 
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.split('').sort().join('') === t.split('').sort().join('')) {
        return true;
    }

    return false;
};

/**
 * Repeated Substring Pattern
 * Given a string s, check if it can be constructed by taking a substring of it and appending
 * multiple copies of the substring together.
 *
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
    let n = s.length;
    
    for (let i = 1; i <= Math.floor(n / 2); i++) {
        if (n % i === 0) { 
            let pattern = s.substring(0, i);
            let repeated = pattern.repeat(n / i);
            if (repeated === s) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Move Zeroes
 * Given an integer array nums, move all 0's to the end of it while maintaining the relative
 * order of the non-zero elements.
 * 
 *
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let nonZeroIndex = 0;

    // Move all non-zero elements to the beginning
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            let temp = nums[i];
            nums[i] = nums[nonZeroIndex];
            nums[nonZeroIndex] = temp;
            nonZeroIndex++;
        }
    }
};

/**
 * Plus One
 * You are given a large integer represented as an integer array digits, 
 * where each digits[i] is the ith digit of the integer. 
 * The digits are ordered from most significant to least significant in left-to-right order.
 * The large integer does not contain any leading 0's.
 * Increment the large integer by one and return the resulting array of digits.
 * 
 * 
 *
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    let lastIndex = digits.length - 1;

    if (digits[lastIndex] < 9) {
        digits[lastIndex]++;
        return digits;
    }

    for (let i = lastIndex; i >= 0; i--) {
        if (digits[i] === 9) {
            digits[i] = 0;
        } else {
            digits[i]++;
            return digits;
        }
    }

    digits.unshift(1); // Adds element to the front of array.
    return digits;
};

/**
 * Sign of the Product of an Array
 * Implement a function signFunc(x) that returns:
 * 1 if x is positive.
 * -1 if x is negative.
 * 0 if x is equal to 0.
 * 
 * You are given an integer array nums. 
 * Let product be the product of all values in the array nums.
 * Return signFunc(product).
 * 
 * @param {number[]} nums
 * @return {number}
 */
var arraySign = function(nums) {
    let product = 1;
    for (let i=0; i<nums.length; i++) {
        product *= nums[i];
    }
    function signFunc(product) {
        if (product > 1) {
            return 1;
        } else if (product < 0) {
            return -1;
        } else {
            return 0;
        }
    }
    return signFunc(product);
    
};

/**
 * Can Make Arithmetic Progression From Sequence
 * A sequence of numbers is called an arithmetic progression if the difference between any
 * two consecutive elements is the same.
 * Given an array of numbers arr, return true if the array can be rearranged to form an
 * arithmetic progression. Otherwise, return false.
 * 
 * @param {number[]} arr
 * @return {boolean}
 */
var canMakeArithmeticProgression = function(arr) {
    
    if (arr.length == 2){ 
        return true;
    } else {
        arr.sort(function(a,b){return a-b});
        console.log(arr)
        for (let i=0; i<arr.length-2; i++) {
            let x = arr[i+1] - arr[i];
            let y = arr[i+2] - arr[i+1];
            if (x != y) {
                return false;
            }
        }
    }

    return true;
};


/**
 * Monotonic Array
 * An array is monotonic if it is either monotone increasing or monotone decreasing.
 * An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. 
 * An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
 * Given an integer array nums, return true if the given array is monotonic, or false otherwise.
 * 
 * @param {number[]} nums
 * @return {boolean}
 */
var isMonotonic = function(nums) {
    let bigcheck = false;
    let smallcheck = false;
    if (nums.length == 1) {
        return true;
    } else {
        for (let i=0; i<nums.length-1; i++) {
            if (nums[i] <= nums[i+1]) {
                smallcheck = true;
            } else {
                smallcheck = false;
                break;
            }
        }

        for (let i=0; i<nums.length-1; i++) {
            if (nums[i] >= nums[i+1]) {
                bigcheck = true;
            } else {
                bigcheck = false;
                break;
            }
        }

        if (bigcheck || smallcheck) {
            return true;
        } else {
            return false;
        }
    }
};


